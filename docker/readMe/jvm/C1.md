### 物流库存扣减流程的并发控制与高可用设计

在物流系统中，库存扣减是高并发场景的核心操作（如电商下单、仓库出货）。多线程/多进程同时扣减可能导致超卖（库存负数）或库存不一致问题。为确保线程安全，我们可以使用 **synchronized** 块/方法控制共享资源、**java.util.concurrent (JUC)** 工具（如 ReentrantLock、AtomicInteger）实现更灵活的锁机制，以及 **不可变对象** 减少共享状态的竞争。同时，为实现 **高可用**（High Availability），需考虑分布式环境：引入分布式锁（如基于 Redis 的 Redisson）、乐观锁（数据库版本控制）、事务回滚、熔断/重试机制，避免单点故障和死锁。

#### 1. 基本流程概述
物流库存扣减的完整流程（伪代码）：
1. **接收请求**：订单服务接收扣减请求（包含商品ID、扣减数量）。
2. **加锁检查**：获取锁，原子性检查库存 ≥ 扣减量。
3. **扣减库存**：更新内存/数据库库存（使用事务）。
4. **更新下游**：通知订单服务、物流服务（异步消息队列如 Kafka）。
5. **释放锁**：确保 finally 块释放。
6. **异常处理**：超时/失败时回滚，重试或补偿（高可用关键）。
7. **监控告警**：记录扣减日志，监控库存阈值。

高可用扩展：
- **单机高可用**：使用 JUC 工具 + 不可变对象。
- **分布式高可用**：Redis 分布式锁 + 数据库乐观锁 + 幂等性（订单唯一ID）。
- **容错**：锁超时（tryLock）、熔断（Hystrix/Sentinel）、服务降级。

下面逐步提供示例代码（Java），从简单到高级。假设库存存储在内存中（实际结合数据库）。

#### 2. 使用 synchronized 控制共享资源
synchronized 是 JVM 内置锁，简单但不可中断、不可超时。适用于低并发单机场景。

**示例：synchronized 方法扣减库存**
```java
public class InventorySynchronized {
    private int stock; // 共享资源

    public InventorySynchronized(int initialStock) {
        this.stock = initialStock;
    }

    // synchronized 方法：自动加锁 this 对象
    public synchronized boolean deduct(int qty) {
        if (stock >= qty) {
            stock -= qty; // 原子操作
            System.out.println("扣减成功，剩余库存: " + stock);
            return true;
        }
        System.out.println("库存不足，无法扣减");
        return false;
    }

    public int getStock() {
        return stock;
    }
}

// 测试（模拟并发）
public class TestSynchronized {
    public static void main(String[] args) {
        InventorySynchronized inv = new InventorySynchronized(10);
        // 模拟 20 个线程并发扣减 1 个
        for (int i = 0; i < 20; i++) {
            new Thread(() -> {
                inv.deduct(1);
            }).start();
        }
    }
}
```
- **优点**：简单，自动处理可见性/有序性。
- **缺点**：不可中断，高并发下性能差（所有线程竞争同一锁）。
- **物流应用**：单仓库低并发扣减。

**synchronized 块示例**（如用户提供的 count++）：
```java
private final Object lockObj = new Object(); // 专用锁对象，避免锁竞争
public void incrementCount() {
    synchronized (lockObj) { // 块级锁，仅锁关键代码
        count++; // 共享变量
    }
    // 其他非关键代码不受锁影响
}
```

#### 3. 使用 JUC 工具：ReentrantLock 保护库存扣减
ReentrantLock 更灵活：支持公平/非公平锁、tryLock（超时避免死锁）、中断。适用于中等并发。

**示例：用 ReentrantLock 保护扣减**
```java
import java.util.concurrent.locks.ReentrantLock;

public class InventoryReentrantLock {
    private int stock;
    private final ReentrantLock lock = new ReentrantLock(); // 可重入锁

    public InventoryReentrantLock(int initialStock) {
        this.stock = initialStock;
    }

    // 用 Lock 保护扣减（物流核心）
    public boolean deduct(int qty) {
        if (lock.tryLock()) { // tryLock() 高可用：非阻塞，失败不等待
            try {
                if (stock >= qty) {
                    stock -= qty;
                    System.out.println("扣减成功，剩余库存: " + stock);
                    return true;
                }
                return false;
            } finally {
                lock.unlock(); // 必须 finally 释放，避免死锁
            }
        } else {
            // 高可用：超时重试或降级（e.g., 抛异常或队列补偿）
            System.out.println("获取锁失败，重试或补偿");
            return false;
        }
    }

    // 支持超时：tryLock(1, TimeUnit.SECONDS)
    public boolean deductWithTimeout(int qty, long timeout, TimeUnit unit) {
        try {
            if (lock.tryLock(timeout, unit)) {
                try {
                    if (stock >= qty) {
                        stock -= qty;
                        return true;
                    }
                    return false;
                } finally {
                    lock.unlock();
                }
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt(); // 恢复中断
            return false;
        }
        return false;
    }

    public int getStock() {
        return stock;
    }
}
```
- **物流应用**：多线程订单扣减，tryLock 确保高可用（锁冲突时不阻塞整个服务）。
- **测试**：类似 synchronized，启动多线程调用 deduct(1)。

#### 4. 使用 AtomicInteger：无锁并发（CAS 机制）
AtomicInteger 使用 CAS（Compare-And-Swap）原子操作，无需显式锁，高性能。适用于读多写少场景。

**示例：AtomicInteger 扣减库存**
```java
import java.util.concurrent.atomic.AtomicInteger;

public class InventoryAtomic {
    private AtomicInteger stock; // 不可变引用，但内部值可原子更新

    public InventoryAtomic(int initialStock) {
        this.stock = new AtomicInteger(initialStock);
    }

    // 无锁扣减：CAS 循环
    public boolean deduct(int qty) {
        int current;
        int newStock;
        do {
            current = stock.get(); // 原子读取
            if (current < qty) {
                System.out.println("库存不足");
                return false;
            }
            newStock = current - qty;
        } while (!stock.compareAndSet(current, newStock)); // CAS 失败重试
        System.out.println("扣减成功，剩余库存: " + newStock);
        return true;
    }

    public int getStock() {
        return stock.get();
    }
}
```
- **优点**：无锁，CPU 自旋重试高效；高可用下减少锁开销。
- **物流应用**：高 QPS 库存检查/扣减，结合数据库最终一致性。
- **不可变对象整合**：返回新 AtomicInteger 实例（immutable 风格）：
  ```java
  public InventoryAtomic deductImmutable(int qty) {
      return new InventoryAtomic(stock.get() - qty); // 新对象，避免共享 mutable 状态
  }
  ```

#### 5. 高可用完善：分布式库存扣减
单机锁不适用于多节点集群（e.g., 微服务）。引入：
- **分布式锁**：Redisson（Redis 基），支持自动续期/看门狗机制。
- **乐观锁**：数据库版本字段（UPDATE stock SET value = value - qty, version = version + 1 WHERE id = ? AND version = ?）。
- **幂等性**：订单ID 唯一，防止重复扣减。
- **补偿机制**：失败时 MQ 回滚库存。

**示例：伪代码 + Redisson 分布式锁（假设已集成 RedissonClient）**
```java
import org.redisson.api.RLock;
import org.redisson.api.RedissonClient;
import java.util.concurrent.TimeUnit;

@Service
public class DistributedInventoryService {
    @Autowired
    private RedissonClient redisson;
    @Autowired
    private InventoryMapper inventoryMapper; // MyBatis 等

    // 分布式扣减流程
    @Transactional(rollbackFor = Exception.class) // 数据库事务
    public boolean deductDistributed(String orderId, int qty) {
        String lockKey = "lock:inventory:" + productId; // 锁键：商品ID
        RLock lock = redisson.getLock(lockKey);
        try {
            // 高可用：tryLock 超时 10s，等待 1s
            if (!lock.tryLock(1, 10, TimeUnit.SECONDS)) {
                // 熔断：记录日志，异步补偿
                log.warn("获取分布式锁失败，订单{}补偿", orderId);
                return false;
            }
            // 1. 数据库乐观锁检查
            Inventory inv = inventoryMapper.selectById(productId);
            if (inv.getStock() < qty || !inventoryMapper.updateStock(productId, inv.getVersion(), qty)) {
                // 更新失败（版本冲突），重试或补偿
                return false;
            }
            // 2. 更新内存缓存（可选，结合双写一致性）
            localCache.put(productId, inv.getStock() - qty);
            // 3. 异步通知物流/订单
            rabbitTemplate.convertAndSend("orderQueue", orderId);
            return true;
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return false;
        } finally {
            if (lock.isHeldByCurrentThread()) {
                lock.unlock(); // 自动释放
            }
        }
    }
}
```
- **数据库 SQL 示例**（乐观锁）：
  ```sql
  -- 查询
  SELECT stock, version FROM inventory WHERE product_id = ?;
  -- 更新（原子）
  UPDATE inventory SET stock = stock - ?, version = version + 1 
  WHERE product_id = ? AND version = ? AND stock >= ?;
  ```
- **高可用保障**：
    - **可用性**：Redis 主从 + Sentinel 集群，锁续期防节点宕机。
    - **一致性**：最终一致（库存先扣内存，后异步同步 DB）。
    - **性能**：Atomic + 分布式锁，QPS > 10k。
    - **监控**：Prometheus 记录扣减 RT/失败率，告警阈值 < 1%。

#### 6. 总结与最佳实践
- **选择依据**：低并发用 synchronized；中高用 ReentrantLock/Atomic；分布式用 Redisson + 乐观锁。
- **不可变对象益处**：减少锁粒度，如用 `record` (Java 14+) 定义 Inventory（自动 immutable）。
- **测试建议**：JMeter 模拟 1000 QPS，验证无超卖。
- **扩展**：集成 Spring Boot + Sentinel 熔断，确保 99.99% 可用。

此设计确保物流库存扣减安全、高效、高可用。如需完整项目代码或特定测试，补充细节！